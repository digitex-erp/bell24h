import express from 'express';
import { createServer, Server as HttpServer } from 'http';
import { Server as SocketIOServer, Socket } from 'socket.io';
import cors from 'cors';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import { activeConnections, messagesReceived, messagesSent, connectionErrors, register } from './utils/metrics';
import { Cluster } from 'cluster';
import * as os from 'os';
import AWS from 'aws-sdk';

// Initialize AWS SDK for Auto Scaling
const autoscaling = new AWS.AutoScaling({
  region: process.env.AWS_REGION || 'ap-south-1',
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
});

// Cluster setup for multi-processing
const cluster = require('cluster') as unknown as Cluster;
const numCPUs = os.cpus().length;

// Types
type ConnectionInfo = {
  id: string;
  connectedAt: Date;
  ip: string;
  userAgent?: string;
  lastPing?: Date;
};

// Initialize environment variables
dotenv.config();

// ES modules fix for __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const PORT = process.env.PORT || 3001;
const CLIENT_URL = process.env.CLIENT_URL || "http://localhost:3000";
const NODE_ENV = process.env.NODE_ENV || 'development';

// Create Express app
const app = express();
const httpServer = createServer(app);

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  try {
    res.set('Content-Type', register.contentType);
    const metrics = await register.metrics();
    res.end(metrics);
  } catch (error) {
    res.status(500).end('Error generating metrics');
  }
});

// Health check with metrics
app.get('/health', (req, res) => {
  const memoryUsage = process.memoryUsage();
  const status = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: {
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      external: memoryUsage.external ? `${Math.round(memoryUsage.external / 1024 / 1024)}MB` : 'N/A',
    },
    activeConnections: activeConnections.labels(process.env.NODE_APP_INSTANCE || '0').get() || 0,
  };
  res.json(status);
});

// Enhanced CORS configuration
const corsOptions = {
  origin: CLIENT_URL,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
};

// Apply CORS to Express
app.use(cors(corsOptions));
app.use(express.json());

// Auto-scaling configuration
const MAX_CONNECTIONS_PER_INSTANCE = parseInt(process.env.MAX_CONNECTIONS_PER_INSTANCE || '10000', 10);
const SCALE_UP_THRESHOLD = parseFloat(process.env.SCALE_UP_THRESHOLD || '0.8');
const SCALE_DOWN_THRESHOLD = parseFloat(process.env.SCALE_DOWN_THRESHOLD || '0.3');

// Track connection count per instance
let connectionCount = 0;

// Function to check if we should scale
async function checkAutoScale() {
  const connectionRatio = connectionCount / MAX_CONNECTIONS_PER_INSTANCE;
  
  if (connectionRatio > SCALE_UP_THRESHOLD) {
    console.log(`High connection load (${connectionRatio.toFixed(2)}), considering scale up`);
    await scaleOut();
  } else if (connectionRatio < SCALE_DOWN_THRESHOLD && connectionCount > 0) {
    console.log(`Low connection load (${connectionRatio.toFixed(2)}), considering scale down`);
    await scaleIn();
  }
}

// Scale out function
async function scaleOut() {
  try {
    const params = {
      AutoScalingGroupName: process.env.AWS_ASG_NAME,
      PolicyName: process.env.AWS_SCALE_OUT_POLICY,
    };
    await autoscaling.executePolicy(params).promise();
    console.log('Scale out policy executed');
  } catch (error) {
    console.error('Error scaling out:', error);
  }
}

// Scale in function
async function scaleIn() {
  try {
    const params = {
      AutoScalingGroupName: process.env.AWS_ASG_NAME,
      PolicyName: process.env.AWS_SCALE_IN_POLICY,
    };
    await autoscaling.executePolicy(params).promise();
    console.log('Scale in policy executed');
  } catch (error) {
    console.error('Error scaling in:', error);
  }
}

// Create Socket.IO server with enhanced options
const io = new SocketIOServer(httpServer, {
  cors: corsOptions,
  path: '/socket.io/',
  serveClient: false,
  connectTimeout: 10000,
  pingTimeout: 5000,
  pingInterval: 10000,
  maxHttpBufferSize: 1e8,
  transports: ['websocket', 'polling']
});

// Track active connections
const activeConnections = new Map<string, ConnectionInfo>();

// Logging helper
const logger = {
  info: (message: string, meta: any = {}) => 
    console.log(`[${new Date().toISOString()}] INFO: ${message}`, Object.keys(meta).length ? meta : ''),
  error: (message: string, error: any = {}) => 
    console.error(`[${new Date().toISOString()}] ERROR: ${message}`, error)
};

// Health check endpoint
app.get('/health', (req, res) => {
  const status = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    server: {
      name: 'bell24h-websocket',
      version: '1.0.0',
      environment: NODE_ENV
    },
    connections: {
      active: io.engine.clientsCount,
      total: io.engine.clientsCount,
      activeConnections: Array.from(activeConnections.keys())
    },
    uptime: process.uptime(),
    memory: process.memoryUsage()
  };
  
  res.json(status);
});

// Server info endpoint
app.get('/server-info', (req, res) => {
  res.json({
    server: {
      name: 'bell24h-websocket',
      version: '1.0.0',
      environment: NODE_ENV,
      nodeVersion: process.version,
      platform: process.platform,
      memory: process.memoryUsage(),
      uptime: process.uptime()
    },
    websocket: {
      protocol: 'socket.io',
      path: '/socket.io/',
      clients: io.engine.clientsCount,
      pingInterval: io.engine.pingInterval,
      pingTimeout: io.engine.pingTimeout
    },
    connections: {
      active: Array.from(activeConnections.entries()).map(([id, info]) => ({
        id,
        connectedAt: info.connectedAt.toISOString(),
        ip: info.ip,
        userAgent: info.userAgent,
        lastPing: info.lastPing?.toISOString() || 'Never'
      }))
    }
  });
});

// Helper to get client IP
const getClientIp = (socket: Socket): string => {
  return (socket.handshake.headers['x-forwarded-for'] as string || '').split(',')[0] || 
         socket.handshake.address || 
         socket.conn.remoteAddress ||
         'unknown';
};

// WebSocket connection handler
io.on('connection', (socket: Socket) => {
  const clientIp = getClientIp(socket);
  const userAgent = socket.handshake.headers['user-agent'] || 'unknown';
  
  // Update connection metrics
  connectionCount++;
  activeConnections.inc();
  
  // Check if we need to scale
  if (connectionCount % 10 === 0) { // Check every 10 connections
    checkAutoScale().catch(console.error);
  }
  const connectionInfo: ConnectionInfo = {
    id: socket.id,
    connectedAt: new Date(),
    ip: clientIp,
    userAgent
  };
  
  activeConnections.set(socket.id, connectionInfo);
  
  logger.info(`Client connected: ${socket.id}`, {
    ip: clientIp,
    userAgent,
    totalConnections: activeConnections.size
  });
  
  // Send welcome message
  socket.emit('welcome', { 
    message: 'Connected to Bell24h WebSocket server',
    id: socket.id,
    timestamp: new Date().toISOString(),
    serverInfo: {
      name: 'bell24h-websocket',
      version: '1.0.0',
      environment: NODE_ENV
    }
  });

  // Handle ping from client
  socket.on('ping', (data: any) => {
    const now = Date.now();
    const pingTimestamp = data.timestamp || now;
    const latency = now - pingTimestamp;
    
    // Update last ping time
    if (activeConnections.has(socket.id)) {
      activeConnections.get(socket.id)!.lastPing = new Date();
    }
    
    logger.info(`Ping from ${socket.id} (${latency}ms)`, {
      clientData: data,
      latency
    });
    
    socket.emit('pong', { 
      ...data,
      serverTime: new Date().toISOString(),
      originalTimestamp: data.timestamp,
      latency,
      serverReceivedAt: now,
      serverProcessedAt: Date.now()
    });
  });

  // File change notification handler
  socket.on('file-change', (data: any) => {
    logger.info(`File change from ${socket.id}`, data);
    
    // Broadcast to all clients except the sender
    socket.broadcast.emit('code-update', {
      type: 'file-change',
      ...data,
      });
    }
    
    // Handle worker exit
    cluster.on('exit', (worker, code, signal) => {
      console.log(`Worker ${worker.process.pid} died`);
      // Restart worker
      cluster.fork();
    });
  } else {
    startServer();
  }
} else {
  // Single process for tests
  startServer();
}
    nodeVersion: process.version,
    platform: process.platform,
    pid: process.pid
  });
  
  logger.info(`ðŸ”Œ WebSocket server running at ws://localhost:${PORT}`, {
    path: '/socket.io/',
    transports: ['websocket', 'polling']
  });
  
  logger.info('ðŸ“Š Server endpoints:', {
    health: `http://localhost:${PORT}/health`,
    serverInfo: `http://localhost:${PORT}/server-info`
  });
});
