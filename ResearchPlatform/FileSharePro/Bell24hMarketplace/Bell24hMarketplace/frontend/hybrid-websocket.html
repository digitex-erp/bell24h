<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bell24h Hybrid Real-Time Communication</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        h2 {
            color: #444;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .message-container {
            border: 1px solid #eee;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
            font-family: monospace;
            background-color: #f9f9f9;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .message.received {
            background-color: #e8f5e9;
        }
        .message.sent {
            background-color: #e3f2fd;
        }
        .message.system {
            background-color: #fff3e0;
            font-style: italic;
        }
        .message.error {
            background-color: #ffebee;
            color: #d32f2f;
        }
        .input-group {
            display: flex;
            margin-bottom: 10px;
        }
        .input-group input {
            flex: 1;
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .settings {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .connection-type {
            font-weight: bold;
            color: #007bff;
        }
        .transport-options {
            display: flex;
            margin: 10px 0;
        }
        .transport-option {
            margin-right: 15px;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-connected {
            background-color: #4CAF50;
        }
        .status-connecting {
            background-color: #ff9800;
        }
        .status-disconnected {
            background-color: #f44336;
        }
        .nav {
            margin-bottom: 20px;
        }
        .nav a {
            color: #0066cc;
            text-decoration: none;
        }
        .nav a:hover {
            text-decoration: underline;
        }
        .debug-info {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
        }
        .transport-info {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="nav">
        <a href="/">‚Üê Back to Home</a> | 
        <a href="/websocket-demo.html">WebSocket Demos</a>
    </div>
    
    <h1>Bell24h Hybrid Real-Time Communication</h1>
    <p>This page demonstrates Bell24h's hybrid real-time communication system that automatically selects the best available transport method.</p>
    
    <div class="card">
        <h2>Connection Status</h2>
        <div>
            Status: <span id="connection-status">Disconnected</span>
            <span id="status-indicator" class="status-indicator status-disconnected"></span>
        </div>
        
        <div>
            Transport: <span id="transport-type" class="connection-type">None</span>
        </div>
        
        <div class="transport-info" id="transport-info">
            Not connected
        </div>
        
        <div class="connection-controls">
            <button id="connect-btn">Connect</button>
            <button id="disconnect-btn" disabled>Disconnect</button>
        </div>
        
        <div class="settings">
            <div class="transport-options">
                <div class="transport-option">
                    <input type="checkbox" id="enable-websocket" checked>
                    <label for="enable-websocket">Enable WebSocket</label>
                </div>
                
                <div class="transport-option">
                    <input type="checkbox" id="enable-sse" checked>
                    <label for="enable-sse">Enable SSE</label>
                </div>
                
                <div class="transport-option">
                    <input type="checkbox" id="enable-polling" checked>
                    <label for="enable-polling">Enable HTTP Polling</label>
                </div>
            </div>
            
            <div>
                <label for="poll-interval">Polling Interval (ms):</label>
                <input type="number" id="poll-interval" value="1000" min="500" max="10000" step="500">
            </div>
            
            <div>
                <input type="checkbox" id="sound-enabled" checked>
                <label for="sound-enabled">Enable notification sounds</label>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2>Messages</h2>
        <div id="message-container" class="message-container"></div>
        
        <div class="input-group">
            <input type="text" id="message-input" placeholder="Type a message..." disabled>
            <button id="send-btn" disabled>Send</button>
        </div>
        
        <div>
            <button id="test-notification-btn">Test Notification</button>
            <button id="simulate-failure-btn">Simulate Transport Failure</button>
        </div>
    </div>
    
    <div class="card">
        <h2>About Hybrid Communication</h2>
        <p>Bell24h's hybrid approach to real-time communication provides maximum reliability and compatibility across all environments.</p>
        
        <p>The system will automatically:</p>
        <ul>
            <li>Try WebSocket first for the best performance</li>
            <li>Fall back to Server-Sent Events if WebSockets are blocked</li>
            <li>Use HTTP polling as a final fallback for complete compatibility</li>
            <li>Switch between transport methods if a connection fails</li>
            <li>Maintain a consistent API regardless of the transport</li>
            <li>Track message IDs to prevent duplicates during transitions</li>
            <li>Provide notifications across all transport types</li>
        </ul>
        
        <p>You can use the checkboxes above to disable different transport methods and see how the system automatically adapts.</p>
        
        <div class="debug-info" id="debug-info"></div>
    </div>
    
    <script type="module">
        import notificationSound from './lib/notificationSounds.js';
        
        // DOM elements
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const messageContainer = document.getElementById('message-container');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const connectionStatus = document.getElementById('connection-status');
        const statusIndicator = document.getElementById('status-indicator');
        const transportType = document.getElementById('transport-type');
        const transportInfo = document.getElementById('transport-info');
        const debugInfo = document.getElementById('debug-info');
        const soundEnabledCheckbox = document.getElementById('sound-enabled');
        const testNotificationBtn = document.getElementById('test-notification-btn');
        const simulateFailureBtn = document.getElementById('simulate-failure-btn');
        const enableWebSocketCheckbox = document.getElementById('enable-websocket');
        const enableSSECheckbox = document.getElementById('enable-sse');
        const enablePollingCheckbox = document.getElementById('enable-polling');
        const pollIntervalInput = document.getElementById('poll-interval');
        
        // Configuration
        const config = {
            clientId: `client_${Math.random().toString(36).substr(2, 9)}`,
            webSocketUrl: 'ws://localhost:5000',
            sseUrl: 'http://localhost:5004/events',
            pollingUrl: 'http://localhost:5003',
            pollingInterval: 1000,
            reconnectDelay: 2000,
            maxReconnectAttempts: 5,
            enableWebSocket: true,
            enableSSE: true,
            enablePolling: true,
            preferredTransportOrder: ['websocket', 'sse', 'polling']
        };
        
        // Connection state
        let state = {
            connected: false,
            connecting: false,
            currentTransport: null,
            reconnectAttempts: 0,
            messageQueue: [],
            lastMessageId: 0,
            pollTimer: null,
            reconnectTimer: null,
            transport: {
                websocket: null,
                sse: null,
                polling: {
                    active: false,
                    lastPollTime: 0
                }
            }
        };
        
        // Initialize sound preferences
        soundEnabledCheckbox.checked = notificationSound.isEnabled();
        
        // Event listeners
        soundEnabledCheckbox.addEventListener('change', () => {
            notificationSound.setEnabled(soundEnabledCheckbox.checked);
        });
        
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        testNotificationBtn.addEventListener('click', testNotification);
        simulateFailureBtn.addEventListener('click', simulateTransportFailure);
        
        enableWebSocketCheckbox.addEventListener('change', () => {
            config.enableWebSocket = enableWebSocketCheckbox.checked;
            updateDebugInfo();
        });
        
        enableSSECheckbox.addEventListener('change', () => {
            config.enableSSE = enableSSECheckbox.checked;
            updateDebugInfo();
        });
        
        enablePollingCheckbox.addEventListener('change', () => {
            config.enablePolling = enablePollingCheckbox.checked;
            updateDebugInfo();
        });
        
        pollIntervalInput.addEventListener('change', () => {
            config.pollingInterval = parseInt(pollIntervalInput.value);
            updateDebugInfo();
            
            // Update polling interval if active
            if (state.currentTransport === 'polling' && state.transport.polling.active) {
                restartPolling();
            }
        });
        
        // Connection functions
        function connect() {
            if (state.connected || state.connecting) return;
            
            state.connecting = true;
            updateStatus('Connecting...', 'connecting');
            addMessage('Connecting to server...', 'system');
            
            // Clear any reconnect timers
            if (state.reconnectTimer) {
                clearTimeout(state.reconnectTimer);
                state.reconnectTimer = null;
            }
            
            // Try to connect using the preferred transport order
            tryNextTransport();
        }
        
        function disconnect() {
            addMessage('Disconnecting from server...', 'system');
            
            // Disconnect from all transports
            disconnectWebSocket();
            disconnectSSE();
            disconnectPolling();
            
            // Clear any timers
            if (state.reconnectTimer) {
                clearTimeout(state.reconnectTimer);
                state.reconnectTimer = null;
            }
            
            // Update state
            state.connected = false;
            state.connecting = false;
            state.currentTransport = null;
            
            // Update UI
            updateStatus('Disconnected', 'disconnected');
            updateTransportInfo('Not connected');
            disconnectBtn.disabled = true;
            connectBtn.disabled = false;
            messageInput.disabled = true;
            sendBtn.disabled = true;
        }
        
        function tryNextTransport() {
            // Filter available transports based on enabled options
            const availableTransports = config.preferredTransportOrder.filter(transport => {
                switch (transport) {
                    case 'websocket': return config.enableWebSocket;
                    case 'sse': return config.enableSSE;
                    case 'polling': return config.enablePolling;
                    default: return false;
                }
            });
            
            if (availableTransports.length === 0) {
                addMessage('No transport methods enabled. Please enable at least one.', 'error');
                state.connecting = false;
                updateStatus('Connection Failed', 'disconnected');
                return;
            }
            
            // Get the next transport type to try
            const currentIndex = state.currentTransport 
                ? availableTransports.indexOf(state.currentTransport) 
                : -1;
            
            const nextIndex = (currentIndex + 1) % availableTransports.length;
            const nextTransport = availableTransports[nextIndex];
            
            addMessage(`Trying transport: ${nextTransport}`, 'system');
            
            // Try to connect with the next transport
            switch (nextTransport) {
                case 'websocket':
                    connectWebSocket();
                    break;
                case 'sse':
                    connectSSE();
                    break;
                case 'polling':
                    connectPolling();
                    break;
                default:
                    addMessage(`Unknown transport: ${nextTransport}`, 'error');
                    scheduleReconnect();
                    break;
            }
        }
        
        // WebSocket functions
        function connectWebSocket() {
            if (state.transport.websocket) {
                state.transport.websocket.close();
            }
            
            try {
                const ws = new WebSocket(config.webSocketUrl);
                state.transport.websocket = ws;
                
                ws.addEventListener('open', () => {
                    onConnected('websocket');
                    addMessage('Connected via WebSocket', 'system');
                });
                
                ws.addEventListener('message', (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage(data);
                    } catch (error) {
                        // Handle plain text messages
                        addMessage(`Received: ${event.data}`, 'received');
                    }
                });
                
                ws.addEventListener('close', () => {
                    if (state.currentTransport === 'websocket') {
                        addMessage('WebSocket connection closed', 'system');
                        onTransportFailed();
                    }
                });
                
                ws.addEventListener('error', (error) => {
                    if (state.currentTransport === 'websocket') {
                        addMessage(`WebSocket error: ${error.message || 'Connection failed'}`, 'error');
                        onTransportFailed();
                    }
                });
                
                // Set a timeout for WebSocket connection
                setTimeout(() => {
                    if (state.connecting && state.transport.websocket === ws && ws.readyState !== WebSocket.OPEN) {
                        addMessage('WebSocket connection timeout', 'error');
                        ws.close();
                        onTransportFailed();
                    }
                }, 5000);
            } catch (error) {
                addMessage(`WebSocket connection error: ${error.message}`, 'error');
                onTransportFailed();
            }
        }
        
        function disconnectWebSocket() {
            if (state.transport.websocket) {
                state.transport.websocket.close();
                state.transport.websocket = null;
            }
        }
        
        // SSE functions
        function connectSSE() {
            if (state.transport.sse) {
                state.transport.sse.close();
                state.transport.sse = null;
            }
            
            try {
                const eventSource = new EventSource(config.sseUrl);
                state.transport.sse = eventSource;
                
                eventSource.onopen = () => {
                    onConnected('sse');
                    addMessage('Connected via Server-Sent Events', 'system');
                };
                
                eventSource.addEventListener('notification', (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage({
                            type: 'notification',
                            data: data
                        });
                    } catch (error) {
                        addMessage(`Error processing SSE notification: ${error.message}`, 'error');
                    }
                });
                
                eventSource.addEventListener('message', (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage({
                            type: 'message',
                            data: data
                        });
                    } catch (error) {
                        addMessage(`Error processing SSE message: ${error.message}`, 'error');
                    }
                });
                
                eventSource.onerror = () => {
                    if (state.currentTransport === 'sse') {
                        addMessage('SSE connection error', 'error');
                        eventSource.close();
                        onTransportFailed();
                    }
                };
                
                // Set a timeout for SSE connection
                setTimeout(() => {
                    if (state.connecting && state.transport.sse === eventSource && state.currentTransport !== 'sse') {
                        addMessage('SSE connection timeout', 'error');
                        eventSource.close();
                        onTransportFailed();
                    }
                }, 5000);
            } catch (error) {
                addMessage(`SSE connection error: ${error.message}`, 'error');
                onTransportFailed();
            }
        }
        
        function disconnectSSE() {
            if (state.transport.sse) {
                state.transport.sse.close();
                state.transport.sse = null;
            }
        }
        
        // HTTP Polling functions
        function connectPolling() {
            addMessage('Connecting via HTTP Polling...', 'system');
            
            // Register with polling server
            fetch(`${config.pollingUrl}/api/register_client`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ client_id: config.clientId })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to register with polling server');
                }
                return response.json();
            })
            .then(() => {
                onConnected('polling');
                startPolling();
                addMessage('Connected via HTTP Polling', 'system');
            })
            .catch(error => {
                addMessage(`Polling connection error: ${error.message}`, 'error');
                onTransportFailed();
            });
        }
        
        function disconnectPolling() {
            if (state.transport.polling.active) {
                // Stop polling
                state.transport.polling.active = false;
                
                if (state.pollTimer) {
                    clearTimeout(state.pollTimer);
                    state.pollTimer = null;
                }
                
                // Unregister client
                fetch(`${config.pollingUrl}/api/unregister_client/${config.clientId}`, {
                    method: 'DELETE'
                }).catch(() => {
                    // Ignore errors during disconnect
                });
            }
        }
        
        function startPolling() {
            state.transport.polling.active = true;
            pollForMessages();
        }
        
        function restartPolling() {
            if (state.pollTimer) {
                clearTimeout(state.pollTimer);
                state.pollTimer = null;
            }
            
            if (state.transport.polling.active) {
                pollForMessages();
            }
        }
        
        function pollForMessages() {
            if (!state.transport.polling.active) return;
            
            state.transport.polling.lastPollTime = Date.now();
            
            fetch(`${config.pollingUrl}/api/get_messages/${config.clientId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Polling request failed');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.messages && data.messages.length > 0) {
                        data.messages.forEach(message => {
                            handleMessage(message);
                        });
                    }
                    
                    // Schedule next poll
                    const elapsed = Date.now() - state.transport.polling.lastPollTime;
                    const nextPoll = Math.max(0, config.pollingInterval - elapsed);
                    
                    state.pollTimer = setTimeout(pollForMessages, nextPoll);
                    updateTransportInfo(`Polling active (interval: ${config.pollingInterval}ms, next: ${nextPoll}ms)`);
                })
                .catch(error => {
                    if (state.currentTransport === 'polling') {
                        addMessage(`Polling error: ${error.message}`, 'error');
                        onTransportFailed();
                    }
                });
        }
        
        // Message handling
        function handleMessage(message) {
            // Basic duplicate detection
            if (message.id && message.id <= state.lastMessageId) {
                return; // Skip duplicate message
            }
            
            if (message.id) {
                state.lastMessageId = message.id;
            }
            
            // Display the message
            addMessage(`Received: ${JSON.stringify(message)}`, 'received');
            
            // Handle different message types
            if (message.type === 'notification') {
                handleNotification(message.data);
            }
        }
        
        function handleNotification(notification) {
            // Play sound based on notification type
            const soundType = notification.sound || notification.type || 'default';
            notificationSound.play(soundType);
            
            // Display visual notification
            showNotification(notification);
        }
        
        function sendMessage() {
            const messageText = messageInput.value.trim();
            if (!messageText) return;
            
            const message = {
                text: messageText,
                timestamp: new Date().toISOString(),
                clientId: config.clientId
            };
            
            sendToServer(message);
            messageInput.value = '';
        }
        
        function sendToServer(message) {
            if (!state.connected) {
                addMessage('Cannot send message: Not connected', 'error');
                return false;
            }
            
            // Add message to display
            addMessage(`Sent: ${JSON.stringify(message)}`, 'sent');
            
            switch (state.currentTransport) {
                case 'websocket': {
                    if (state.transport.websocket && state.transport.websocket.readyState === WebSocket.OPEN) {
                        state.transport.websocket.send(JSON.stringify(message));
                        return true;
                    }
                    break;
                }
                
                case 'polling': {
                    fetch(`${config.pollingUrl}/api/send_message`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            client_id: config.clientId,
                            message: message
                        })
                    }).catch(error => {
                        addMessage(`Error sending message: ${error.message}`, 'error');
                    });
                    return true;
                }
                
                case 'sse': {
                    // For SSE, we need to use a separate HTTP endpoint to send messages
                    fetch(`${config.sseUrl.replace('/events', '')}/send_message`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            client_id: config.clientId,
                            message: message
                        })
                    }).catch(error => {
                        addMessage(`Error sending message: ${error.message}`, 'error');
                    });
                    return true;
                }
            }
            
            addMessage('Failed to send message: Transport not available', 'error');
            return false;
        }
        
        // Event handlers
        function onConnected(transport) {
            state.connected = true;
            state.connecting = false;
            state.currentTransport = transport;
            state.reconnectAttempts = 0;
            
            // Update UI
            updateStatus('Connected', 'connected');
            disconnectBtn.disabled = false;
            connectBtn.disabled = true;
            messageInput.disabled = false;
            sendBtn.disabled = false;
            
            // Update transport info
            updateTransportInfo(getTransportDetails(transport));
            
            // Send any queued messages
            while (state.messageQueue.length > 0) {
                const message = state.messageQueue.shift();
                sendToServer(message);
            }
        }
        
        function onTransportFailed() {
            // Track the failed transport
            const failedTransport = state.currentTransport;
            
            // Reset current transport
            state.currentTransport = null;
            
            // Check if we're still connecting or connected
            if (state.connecting || state.connected) {
                // When a transport fails, try the next one
                addMessage(`Transport ${failedTransport} failed, trying another...`, 'system');
                
                // Update status
                updateStatus('Reconnecting...', 'connecting');
                
                // Update the UI
                disconnectBtn.disabled = true;
                connectBtn.disabled = true;
                messageInput.disabled = true;
                sendBtn.disabled = true;
                
                // Try the next transport
                tryNextTransport();
            }
        }
        
        // Utility functions
        function addMessage(message, type = 'system') {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', type);
            
            const timestamp = new Date().toLocaleTimeString();
            messageElement.textContent = `[${timestamp}] ${message}`;
            
            messageContainer.appendChild(messageElement);
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }
        
        function updateStatus(status, state) {
            connectionStatus.textContent = status;
            statusIndicator.className = `status-indicator status-${state}`;
        }
        
        function updateTransportInfo(info) {
            transportType.textContent = state.currentTransport || 'None';
            transportInfo.textContent = info;
        }
        
        function updateDebugInfo() {
            const transportStatus = {
                websocket: config.enableWebSocket ? 'Enabled' : 'Disabled',
                sse: config.enableSSE ? 'Enabled' : 'Disabled',
                polling: config.enablePolling ? 'Enabled' : 'Disabled'
            };
            
            debugInfo.textContent = `Available transports: WebSocket (${transportStatus.websocket}), SSE (${transportStatus.sse}), Polling (${transportStatus.polling})`;
        }
        
        function getTransportDetails(transport) {
            switch (transport) {
                case 'websocket':
                    return 'WebSocket connection established (bidirectional, real-time)';
                case 'sse':
                    return 'Server-Sent Events connection established (server-to-client, real-time)';
                case 'polling':
                    return `HTTP Polling connection active (polling every ${config.pollingInterval}ms)`;
                default:
                    return 'Unknown transport';
            }
        }
        
        function scheduleReconnect() {
            state.reconnectAttempts++;
            
            if (state.reconnectAttempts > config.maxReconnectAttempts) {
                addMessage(`Maximum reconnect attempts (${config.maxReconnectAttempts}) reached. Please try connecting again manually.`, 'error');
                state.connecting = false;
                updateStatus('Connection Failed', 'disconnected');
                connectBtn.disabled = false;
                return;
            }
            
            const delay = config.reconnectDelay * Math.min(10, Math.pow(1.5, state.reconnectAttempts - 1));
            addMessage(`Reconnecting in ${Math.round(delay / 1000)} seconds (attempt ${state.reconnectAttempts})...`, 'system');
            
            state.reconnectTimer = setTimeout(() => {
                tryNextTransport();
            }, delay);
        }
        
        function testNotification() {
            // Create a test notification
            const notification = {
                title: 'Test Notification',
                message: 'This is a test notification from the Hybrid WebSocket demo',
                type: 'default',
                timestamp: new Date().toISOString()
            };
            
            // If connected, try to send through server
            if (state.connected) {
                const message = {
                    type: 'notification',
                    data: notification
                };
                
                sendToServer(message);
            }
            
            // Also show a local notification for testing
            handleNotification(notification);
        }
        
        function simulateTransportFailure() {
            if (!state.connected) {
                addMessage('Not connected - nothing to simulate', 'system');
                return;
            }
            
            const currentTransport = state.currentTransport;
            addMessage(`Simulating failure on current transport: ${currentTransport}`, 'system');
            
            switch (currentTransport) {
                case 'websocket':
                    if (state.transport.websocket) {
                        state.transport.websocket.close();
                    }
                    break;
                    
                case 'sse':
                    if (state.transport.sse) {
                        state.transport.sse.close();
                    }
                    break;
                    
                case 'polling':
                    disconnectPolling();
                    onTransportFailed();
                    break;
            }
        }
        
        function showNotification(data) {
            // Display a visual notification
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = '#d4edda';
            notification.style.color = '#155724';
            notification.style.padding = '12px 20px';
            notification.style.borderRadius = '4px';
            notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
            notification.style.zIndex = '9999';
            notification.style.transition = 'opacity 0.3s, transform 0.3s';
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px)';
            
            const title = document.createElement('div');
            title.style.fontWeight = 'bold';
            title.textContent = data.title || 'Notification';
            
            const message = document.createElement('div');
            message.textContent = data.message || '';
            
            notification.appendChild(title);
            notification.appendChild(message);
            document.body.appendChild(notification);
            
            // Show the notification
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove the notification after 5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 5000);
        }
        
        // Initialize
        updateDebugInfo();
    </script>
</body>
</html>