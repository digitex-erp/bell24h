<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bell24h HTTP Polling (WebSocket Emulation)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        h2 {
            color: #444;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .message-container {
            border: 1px solid #eee;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
            font-family: monospace;
            background-color: #f9f9f9;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .message.received {
            background-color: #e8f5e9;
        }
        .message.sent {
            background-color: #e3f2fd;
        }
        .message.system {
            background-color: #fff3e0;
            font-style: italic;
        }
        .message.error {
            background-color: #ffebee;
            color: #d32f2f;
        }
        .input-group {
            display: flex;
            margin-bottom: 10px;
        }
        .input-group input {
            flex: 1;
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .settings {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-connected {
            background-color: #4CAF50;
        }
        .status-connecting {
            background-color: #ff9800;
        }
        .status-disconnected {
            background-color: #f44336;
        }
        .nav {
            margin-bottom: 20px;
        }
        .nav a {
            color: #0066cc;
            text-decoration: none;
        }
        .nav a:hover {
            text-decoration: underline;
        }
        .debug-info {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
        }
        .poll-status {
            font-style: italic;
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="nav">
        <a href="/">‚Üê Back to Home</a> | 
        <a href="/websocket-demo.html">WebSocket Demos</a>
    </div>
    
    <h1>HTTP Polling (WebSocket Emulation)</h1>
    <p>This page demonstrates Bell24h's HTTP polling implementation that emulates WebSocket functionality as a fallback option.</p>
    
    <div class="card">
        <h2>Connection Status</h2>
        <div class="connection-status">
            Status: <span id="connection-status">Disconnected</span>
            <span id="status-indicator" class="status-indicator status-disconnected"></span>
        </div>
        
        <div class="poll-status" id="poll-status">Not polling</div>
        
        <div class="connection-controls">
            <button id="connect-btn">Connect</button>
            <button id="disconnect-btn" disabled>Disconnect</button>
        </div>
        
        <div class="settings">
            <div>
                <label for="server-url">Server URL:</label>
                <input type="text" id="server-url" value="http://localhost:5003" style="width: 250px;">
            </div>
            
            <div>
                <label for="client-id">Client ID:</label>
                <input type="text" id="client-id" readonly style="width: 250px;">
            </div>
            
            <div>
                <label for="poll-interval">Polling Interval (ms):</label>
                <input type="number" id="poll-interval" value="1000" min="500" max="10000" step="500">
            </div>
            
            <div>
                <input type="checkbox" id="sound-enabled" checked>
                <label for="sound-enabled">Enable sounds</label>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2>Messages</h2>
        <div id="message-container" class="message-container"></div>
        
        <div class="input-group">
            <input type="text" id="message-input" placeholder="Type a message..." disabled>
            <button id="send-btn" disabled>Send</button>
        </div>
        
        <div>
            <button id="test-notification-btn">Test Notification</button>
        </div>
    </div>
    
    <div class="card">
        <h2>How HTTP Polling Works</h2>
        <p>HTTP polling is used as a fallback when WebSockets or SSE are unavailable due to network restrictions, firewalls, or browser limitations.</p>
        
        <p>Key principles of our implementation:</p>
        <ul>
            <li>The client periodically sends GET requests to check for new messages</li>
            <li>The server returns any pending messages since the last poll</li>
            <li>Messages from client to server are sent as POST requests</li>
            <li>Each client is identified by a unique client ID</li>
            <li>The client can control the polling frequency (interval)</li>
            <li>Network failures are automatically handled with exponential backoff</li>
        </ul>
        
        <p>While less efficient than WebSockets or SSE, HTTP polling ensures Bell24h users always have a reliable real-time communication option.</p>
        
        <div class="debug-info" id="debug-info"></div>
    </div>
    
    <script type="module">
        import notificationSound from './lib/notificationSounds.js';
        
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const serverUrlInput = document.getElementById('server-url');
        const clientIdInput = document.getElementById('client-id');
        const pollIntervalInput = document.getElementById('poll-interval');
        const messageContainer = document.getElementById('message-container');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const connectionStatus = document.getElementById('connection-status');
        const statusIndicator = document.getElementById('status-indicator');
        const pollStatusElement = document.getElementById('poll-status');
        const debugInfoElement = document.getElementById('debug-info');
        const soundEnabledCheckbox = document.getElementById('sound-enabled');
        const testNotificationBtn = document.getElementById('test-notification-btn');
        
        let clientId = null;
        let polling = false;
        let pollInterval = 1000;
        let pollTimer = null;
        let lastPollTime = 0;
        let reconnectAttempts = 0;
        let baseUrl = '';
        
        // Initialize sound preferences
        soundEnabledCheckbox.checked = notificationSound.isEnabled();
        
        // Sound settings change handler
        soundEnabledCheckbox.addEventListener('change', () => {
            notificationSound.setEnabled(soundEnabledCheckbox.checked);
        });
        
        // Generate a random client ID
        clientIdInput.value = `client_${Math.random().toString(36).substr(2, 9)}`;
        
        // Connect button handler
        connectBtn.addEventListener('click', connect);
        
        // Disconnect button handler
        disconnectBtn.addEventListener('click', disconnect);
        
        // Poll interval change handler
        pollIntervalInput.addEventListener('change', () => {
            pollInterval = parseInt(pollIntervalInput.value, 10);
            if (polling) {
                stopPolling();
                startPolling();
            }
        });
        
        // Send message handler
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // Test notification handler
        testNotificationBtn.addEventListener('click', () => {
            if (polling) {
                fetch(`${baseUrl}/api/send_message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'notification',
                        client_id: clientId,
                        message: {
                            title: 'Test Notification',
                            message: 'This is a test notification from the HTTP Polling demo',
                            timestamp: new Date().toISOString(),
                            sound: 'default'
                        }
                    })
                })
                .then(response => {
                    if (response.ok) {
                        addMessage('Test notification sent to server', 'system');
                        return response.json();
                    }
                    throw new Error('Failed to send test notification');
                })
                .catch(error => {
                    addMessage(`Error: ${error.message}`, 'error');
                    // Simulate a notification anyway for testing
                    simulateNotification();
                });
            } else {
                // Simulate notification if not connected
                simulateNotification();
                addMessage('Simulated notification (not connected to server)', 'system');
            }
        });
        
        function connect() {
            const serverUrl = serverUrlInput.value.trim();
            baseUrl = serverUrl;
            clientId = clientIdInput.value.trim();
            
            if (!clientId) {
                clientId = `client_${Math.random().toString(36).substr(2, 9)}`;
                clientIdInput.value = clientId;
            }
            
            updateConnectionStatus('Connecting...', 'connecting');
            
            // Register with the server
            fetch(`${baseUrl}/api/register_client`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ client_id: clientId })
            })
            .then(response => {
                if (response.ok) {
                    updateConnectionStatus('Connected', 'connected');
                    addMessage(`Connected to ${serverUrl}`, 'system');
                    
                    // Enable controls
                    disconnectBtn.disabled = false;
                    connectBtn.disabled = true;
                    messageInput.disabled = false;
                    sendBtn.disabled = false;
                    
                    // Start polling for messages
                    startPolling();
                    
                    // Reset reconnect attempts
                    reconnectAttempts = 0;
                    
                    return response.json();
                }
                throw new Error('Failed to register client');
            })
            .then(data => {
                addMessage(`Registered with server: ${JSON.stringify(data)}`, 'system');
            })
            .catch(error => {
                updateConnectionStatus('Connection Failed', 'disconnected');
                addMessage(`Error: ${error.message}`, 'error');
                
                // Try to reconnect with exponential backoff
                scheduleReconnect();
            });
        }
        
        function disconnect() {
            // Stop polling
            stopPolling();
            
            // Unregister from server
            if (clientId) {
                fetch(`${baseUrl}/api/unregister_client/${clientId}`, {
                    method: 'DELETE'
                })
                .then(response => {
                    if (response.ok) {
                        addMessage('Disconnected from server', 'system');
                        return response.json();
                    }
                    throw new Error('Failed to unregister client');
                })
                .then(data => {
                    addMessage(`Server response: ${JSON.stringify(data)}`, 'system');
                })
                .catch(error => {
                    addMessage(`Error unregistering: ${error.message}`, 'error');
                });
            }
            
            // Update UI
            updateConnectionStatus('Disconnected', 'disconnected');
            
            // Disable controls
            disconnectBtn.disabled = true;
            connectBtn.disabled = false;
            messageInput.disabled = true;
            sendBtn.disabled = true;
        }
        
        function startPolling() {
            if (polling) return;
            
            polling = true;
            pollStatusElement.textContent = `Polling every ${pollInterval}ms`;
            
            // Start the polling loop
            pollMessages();
        }
        
        function stopPolling() {
            polling = false;
            
            if (pollTimer) {
                clearTimeout(pollTimer);
                pollTimer = null;
            }
            
            pollStatusElement.textContent = 'Not polling';
        }
        
        function pollMessages() {
            if (!polling) return;
            
            const now = Date.now();
            lastPollTime = now;
            
            fetch(`${baseUrl}/api/get_messages/${clientId}`)
                .then(response => {
                    if (response.ok) {
                        // Reset reconnect attempts on successful poll
                        reconnectAttempts = 0;
                        return response.json();
                    }
                    throw new Error('Failed to poll messages');
                })
                .then(data => {
                    // Process any messages
                    if (data.messages && data.messages.length > 0) {
                        data.messages.forEach(message => {
                            processMessage(message);
                        });
                    }
                    
                    // Schedule next poll
                    const elapsed = Date.now() - lastPollTime;
                    const nextPoll = Math.max(0, pollInterval - elapsed);
                    
                    debugInfoElement.textContent = `Last poll: ${new Date().toLocaleTimeString()} | Next poll: ${nextPoll}ms | Messages: ${data.messages ? data.messages.length : 0}`;
                    
                    pollTimer = setTimeout(pollMessages, nextPoll);
                })
                .catch(error => {
                    addMessage(`Polling error: ${error.message}`, 'error');
                    
                    // Increase reconnect attempts
                    reconnectAttempts++;
                    
                    // Exponential backoff for reconnecting
                    const backoffTime = Math.min(30000, Math.pow(2, reconnectAttempts - 1) * 1000);
                    
                    debugInfoElement.textContent = `Error: ${error.message} | Retry in: ${backoffTime/1000}s | Attempt: ${reconnectAttempts}`;
                    
                    // Try again after backoff time
                    pollTimer = setTimeout(pollMessages, backoffTime);
                });
        }
        
        function processMessage(message) {
            // Display the message
            addMessage(`Received: ${JSON.stringify(message)}`, 'received');
            
            // Handle different message types
            if (message.type === 'notification') {
                handleNotification(message);
            }
        }
        
        function handleNotification(notification) {
            // Play sound based on notification type
            const soundType = notification.sound || notification.type || 'default';
            
            notificationSound.play(soundType)
                .then(() => console.log(`Played ${soundType} sound`))
                .catch(error => console.error('Error playing sound:', error));
            
            // Display a visual notification
            const notificationElement = document.createElement('div');
            notificationElement.style.position = 'fixed';
            notificationElement.style.top = '20px';
            notificationElement.style.right = '20px';
            notificationElement.style.backgroundColor = '#d4edda';
            notificationElement.style.color = '#155724';
            notificationElement.style.padding = '12px 20px';
            notificationElement.style.borderRadius = '4px';
            notificationElement.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
            notificationElement.style.zIndex = '9999';
            notificationElement.style.transition = 'opacity 0.3s, transform 0.3s';
            notificationElement.style.opacity = '0';
            notificationElement.style.transform = 'translateY(-20px)';
            
            const title = document.createElement('div');
            title.style.fontWeight = 'bold';
            title.textContent = notification.title || 'Notification';
            
            const message = document.createElement('div');
            message.textContent = notification.message || '';
            
            notificationElement.appendChild(title);
            notificationElement.appendChild(message);
            document.body.appendChild(notificationElement);
            
            // Show the notification
            setTimeout(() => {
                notificationElement.style.opacity = '1';
                notificationElement.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove the notification after 5 seconds
            setTimeout(() => {
                notificationElement.style.opacity = '0';
                notificationElement.style.transform = 'translateY(-20px)';
                
                setTimeout(() => {
                    document.body.removeChild(notificationElement);
                }, 300);
            }, 5000);
        }
        
        function sendMessage() {
            const messageText = messageInput.value.trim();
            
            if (!messageText) return;
            
            // Send the message to the server
            fetch(`${baseUrl}/api/send_message`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    client_id: clientId,
                    message: messageText
                })
            })
            .then(response => {
                if (response.ok) {
                    addMessage(`Sent: ${messageText}`, 'sent');
                    messageInput.value = '';
                    return response.json();
                }
                throw new Error('Failed to send message');
            })
            .catch(error => {
                addMessage(`Error sending message: ${error.message}`, 'error');
            });
        }
        
        function addMessage(message, type = 'system') {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', type);
            
            const timestamp = new Date().toLocaleTimeString();
            messageElement.textContent = `[${timestamp}] ${message}`;
            
            messageContainer.appendChild(messageElement);
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }
        
        function updateConnectionStatus(status, state) {
            connectionStatus.textContent = status;
            statusIndicator.className = `status-indicator status-${state}`;
        }
        
        function scheduleReconnect() {
            reconnectAttempts++;
            
            const backoffTime = Math.min(30000, Math.pow(2, reconnectAttempts - 1) * 1000);
            addMessage(`Reconnecting in ${backoffTime/1000} seconds...`, 'system');
            
            setTimeout(connect, backoffTime);
        }
        
        function simulateNotification() {
            // Generate a random notification type
            const notificationTypes = ['default', 'message', 'rfq', 'bid', 'payment', 'delivery', 'verification'];
            const randomType = notificationTypes[Math.floor(Math.random() * notificationTypes.length)];
            
            // Create notification data based on type
            let title, message;
            switch (randomType) {
                case 'message':
                    title = 'New Message Received';
                    message = 'You have received a new message from a buyer';
                    break;
                case 'rfq':
                    title = 'New RFQ Posted';
                    message = 'A new Request for Quote has been posted in your category';
                    break;
                case 'bid':
                    title = 'Bid Status Updated';
                    message = 'Your bid status has been changed to "Under Review"';
                    break;
                case 'payment':
                    title = 'Payment Processed';
                    message = 'A payment of ‚Çπ15,000 has been processed';
                    break;
                case 'delivery':
                    title = 'Delivery Update';
                    message = 'Your shipment will arrive in 2 business days';
                    break;
                case 'verification':
                    title = 'Verification Complete';
                    message = 'Your business verification has been completed';
                    break;
                default:
                    title = 'Notification';
                    message = 'You have a new notification';
            }
            
            // Create and process notification
            const notification = {
                type: 'notification',
                title: title,
                message: message,
                timestamp: new Date().toISOString(),
                sound: randomType
            };
            
            handleNotification(notification);
        }
    </script>
</body>
</html>